# å‚ç›´çŸ¥è¯†é›†æˆæŠ€æœ¯æ–¹æ¡ˆ

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°å¦‚ä½•åœ¨ Univers ç³»ç»Ÿä¸­æŠ€æœ¯æ€§åœ°é›†æˆå’Œç®¡ç†å‚ç›´é¢†åŸŸçŸ¥è¯†ã€‚

**ç›®æ ‡**ï¼š
1. è®© AI èƒ½æ‰§è¡Œå¯ç¼–ç çŸ¥è¯†
2. è®© AI èƒ½å­¦ä¹ æƒ…å¢ƒçŸ¥è¯†
3. è®©ç³»ç»Ÿèƒ½æ•è·ã€æ²‰æ·€ã€å¤ç”¨å…ƒå±‚çŸ¥è¯†
4. æ„å»ºçŸ¥è¯†é£è½®çš„æŠ€æœ¯åŸºç¡€è®¾æ–½

**éç›®æ ‡**ï¼š
- âŒ è®© AI ç”Ÿæˆå…ƒå±‚çŸ¥è¯†ï¼ˆAI åšä¸åˆ°ï¼‰
- âŒ å®Œå…¨è‡ªåŠ¨åŒ–çŸ¥è¯†ç®¡ç†ï¼ˆéœ€è¦äººç±»åˆ¤æ–­ï¼‰

---

## ä¸€ã€ç³»ç»Ÿæ¶æ„

### 1.1 ä¸‰å±‚çŸ¥è¯†æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           å…ƒå±‚çŸ¥è¯†å±‚ (Meta Layer)             â”‚
â”‚   - æ´å¯Ÿåº“ (Insight Repository)              â”‚
â”‚   - ç¼©æ”¾æç¤ºå¼•æ“ (Scale Reminder Engine)      â”‚
â”‚   - äººç±»ä¸»å¯¼ + AI è¾…åŠ©                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“ é©±åŠ¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         æƒ…å¢ƒçŸ¥è¯†å±‚ (Contextual Layer)         â”‚
â”‚   - ç»éªŒæ¨¡å¼åº“ (Pattern Library)             â”‚
â”‚   - æƒ…å¢ƒåŒ¹é…å¼•æ“ (Context Matcher)           â”‚
â”‚   - äººæœºåä½œ                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“ æŒ‡å¯¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        å¯ç¼–ç çŸ¥è¯†å±‚ (Codifiable Layer)        â”‚
â”‚   - è§„åˆ™å¼•æ“ (Rule Engine)                   â”‚
â”‚   - å‚æ•°åº“ (Parameter Database)              â”‚
â”‚   - AI ä¸»å¯¼æ‰§è¡Œ                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒç»„ä»¶

#### ç»„ä»¶ 1ï¼šçŸ¥è¯†æ•è·ç³»ç»Ÿ (Knowledge Capture)
**èŒè´£**ï¼šä½æ‘©æ“¦åœ°è®°å½•ä¸“å®¶çš„å·¥ä½œæµä¸­äº§ç”Ÿçš„çŸ¥è¯†

**æŠ€æœ¯æ ˆ**ï¼š
- å‰ç«¯ï¼šå·¥ä½œæµä¸­è‡ªç„¶åµŒå…¥çš„è¡¨å•ã€è¯­éŸ³è¾“å…¥
- åç«¯ï¼šçŸ¥è¯†æå–ç®¡é“ (NLP + ç»“æ„åŒ–)
- å­˜å‚¨ï¼šå¤šæ¨¡æ€çŸ¥è¯†åº“ (å‘é‡æ•°æ®åº“ + å…³ç³»æ•°æ®åº“ + å›¾æ•°æ®åº“)

---

#### ç»„ä»¶ 2ï¼šçŸ¥è¯†æ‰§è¡Œç³»ç»Ÿ (Knowledge Execution)
**èŒè´£**ï¼šè®© AI æ‰§è¡Œå·²æœ‰çš„çŸ¥è¯†

**æŠ€æœ¯æ ˆ**ï¼š
- å¯ç¼–ç çŸ¥è¯†ï¼šè§„åˆ™å¼•æ“ (Drools / è‡ªç ”)
- æƒ…å¢ƒçŸ¥è¯†ï¼šRAG (æ£€ç´¢å¢å¼ºç”Ÿæˆ)
- å…ƒå±‚çŸ¥è¯†ï¼šæç¤ºè¯å·¥ç¨‹ + å¼•å¯¼å¼å¯¹è¯

---

#### ç»„ä»¶ 3ï¼šçŸ¥è¯†æ¼”åŒ–ç³»ç»Ÿ (Knowledge Evolution)
**èŒè´£**ï¼šçŸ¥è¯†çš„éªŒè¯ã€æ›´æ–°ã€æ·˜æ±°

**æŠ€æœ¯æ ˆ**ï¼š
- æ•ˆæœè¿½è¸ªï¼šA/B æµ‹è¯•æ¡†æ¶
- çŸ¥è¯†è¯„åˆ†ï¼šè´¡çŒ®è€…å£°èª‰ç³»ç»Ÿ
- è‡ªåŠ¨æ·˜æ±°ï¼šä½è´¨é‡çŸ¥è¯†é™æƒ/åˆ é™¤

---

#### ç»„ä»¶ 4ï¼šç¼©æ”¾æç¤ºå¼•æ“ (Scale Reminder)
**èŒè´£**ï¼šæé†’ç”¨æˆ·"è¢«å¿½è§†çš„å°ºåº¦"ï¼ˆå‚è§ [architecture.md](architecture.md) ç¬¬ 3 èŠ‚ï¼‰

**æŠ€æœ¯æ ˆ**ï¼š
- å°ºåº¦æ£€æµ‹ï¼šLLM åˆ†æå†³ç­–çš„éšå«å°ºåº¦
- æé†’ç”Ÿæˆï¼šå¯¹æ¯”å¤šä¸ªå°ºåº¦ï¼Œç”Ÿæˆæé†’
- æ’å…¥æ—¶æœºï¼šåœ¨ç”¨æˆ·åšå†³ç­–æ—¶ä¸»åŠ¨ä»‹å…¥

---

## äºŒã€å¯ç¼–ç çŸ¥è¯†ç®¡ç†

### 2.1 æ•°æ®æ¨¡å‹

```python
from dataclasses import dataclass
from typing import List, Dict, Any
from enum import Enum

class KnowledgeType(Enum):
    RULE = "rule"           # è§„åˆ™
    FORMULA = "formula"     # å…¬å¼
    PROCEDURE = "procedure" # æµç¨‹
    STANDARD = "standard"   # æ ‡å‡†

@dataclass
class CodifiableKnowledge:
    """å¯ç¼–ç çŸ¥è¯†çš„æ•°æ®ç»“æ„"""

    id: str
    type: KnowledgeType
    domain: str              # ä¾‹å¦‚ï¼š"HVAC", "lighting", "security"
    subdomain: str           # ä¾‹å¦‚ï¼š"cooling", "heating", "ventilation"

    # çŸ¥è¯†å†…å®¹
    name: str
    description: str
    content: Dict[str, Any]  # ç»“æ„åŒ–å†…å®¹

    # é€‚ç”¨æ¡ä»¶
    conditions: List[str]    # ä¾‹å¦‚ï¼š["outdoor_temp < 5", "humidity > 60%"]

    # æ•ˆæœæ•°æ®
    effectiveness: float     # 0-1ï¼ŒåŸºäºå†å²ä½¿ç”¨æ•ˆæœ
    usage_count: int
    success_rate: float

    # å…ƒæ•°æ®
    source: str              # æ¥æºï¼šä¸“å®¶ã€æ–‡çŒ®ã€æ•°æ®æŒ–æ˜
    created_at: str
    updated_at: str
    verified: bool


# ç¤ºä¾‹ï¼šHVAC å‚æ•°ä¼˜åŒ–è§„åˆ™
example_rule = CodifiableKnowledge(
    id="rule_hvac_001",
    type=KnowledgeType.RULE,
    domain="HVAC",
    subdomain="heating",

    name="ä½æ¸©åœºæ™¯èŠ‚èƒ½è§„åˆ™",
    description="å½“å®¤å¤–æ¸©åº¦ä½äº 5Â°C æ—¶ï¼Œé€‚å½“é™ä½å®¤å†…ç›®æ ‡æ¸©åº¦å’Œæ¹¿åº¦å¯èŠ‚èƒ½ 10-15%",
    content={
        "action": "adjust_targets",
        "parameters": {
            "indoor_temp_delta": -2,      # é™ä½ 2Â°C
            "humidity_delta": -5,          # é™ä½ 5%
        },
        "expected_saving": 0.12            # é¢„æœŸèŠ‚èƒ½ 12%
    },

    conditions=[
        "outdoor_temp < 5",
        "heating_mode == True",
        "building_type in ['office', 'retail']"
    ],

    effectiveness=0.87,
    usage_count=234,
    success_rate=0.85,

    source="aggregated_from_100_customers",
    created_at="2024-11-15",
    updated_at="2025-01-20",
    verified=True
)
```

### 2.2 è§„åˆ™å¼•æ“

```python
class RuleEngine:
    """
    æ‰§è¡Œå¯ç¼–ç çŸ¥è¯†çš„å¼•æ“
    """

    def __init__(self, knowledge_base: List[CodifiableKnowledge]):
        self.knowledge_base = knowledge_base
        self.index = self._build_index()

    def _build_index(self):
        """æ„å»ºå¿«é€ŸæŸ¥è¯¢ç´¢å¼•"""
        index = {}
        for k in self.knowledge_base:
            key = f"{k.domain}:{k.subdomain}"
            if key not in index:
                index[key] = []
            index[key].append(k)
        return index

    def find_applicable_knowledge(self, context: Dict[str, Any]) -> List[CodifiableKnowledge]:
        """
        æ‰¾åˆ°é€‚ç”¨äºå½“å‰æƒ…å¢ƒçš„çŸ¥è¯†

        Args:
            context: å½“å‰æƒ…å¢ƒï¼Œä¾‹å¦‚ï¼š
                {
                    "domain": "HVAC",
                    "subdomain": "heating",
                    "outdoor_temp": 3,
                    "heating_mode": True,
                    "building_type": "office"
                }

        Returns:
            é€‚ç”¨çš„çŸ¥è¯†åˆ—è¡¨ï¼ŒæŒ‰ effectiveness æ’åº
        """
        key = f"{context['domain']}:{context['subdomain']}"
        candidates = self.index.get(key, [])

        applicable = []
        for k in candidates:
            if self._check_conditions(k.conditions, context):
                applicable.append(k)

        # æŒ‰æ•ˆæœæ’åº
        applicable.sort(key=lambda x: x.effectiveness, reverse=True)
        return applicable

    def _check_conditions(self, conditions: List[str], context: Dict[str, Any]) -> bool:
        """æ£€æŸ¥æ¡ä»¶æ˜¯å¦æ»¡è¶³"""
        for cond in conditions:
            try:
                # ç®€å•çš„è¡¨è¾¾å¼æ±‚å€¼ï¼ˆç”Ÿäº§ç¯å¢ƒéœ€è¦æ›´å®‰å…¨çš„å®ç°ï¼‰
                if not eval(cond, {"__builtins__": {}}, context):
                    return False
            except:
                return False
        return True

    def execute(self, knowledge: CodifiableKnowledge, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        æ‰§è¡ŒçŸ¥è¯†

        Returns:
            æ‰§è¡Œç»“æœå’Œæ¨èçš„è¡ŒåŠ¨
        """
        return {
            "knowledge_id": knowledge.id,
            "knowledge_name": knowledge.name,
            "action": knowledge.content["action"],
            "parameters": knowledge.content["parameters"],
            "expected_outcome": knowledge.content.get("expected_saving"),
            "confidence": knowledge.effectiveness,
            "explanation": f"{knowledge.description}ï¼ˆåŸºäº {knowledge.usage_count} æ¬¡å†å²ä½¿ç”¨ï¼ŒæˆåŠŸç‡ {knowledge.success_rate:.1%}ï¼‰"
        }


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # åˆå§‹åŒ–è§„åˆ™å¼•æ“
    engine = RuleEngine([example_rule])

    # å½“å‰æƒ…å¢ƒ
    context = {
        "domain": "HVAC",
        "subdomain": "heating",
        "outdoor_temp": 3,
        "heating_mode": True,
        "building_type": "office"
    }

    # æŸ¥æ‰¾é€‚ç”¨çŸ¥è¯†
    applicable = engine.find_applicable_knowledge(context)

    if applicable:
        # æ‰§è¡Œæœ€ä½³çŸ¥è¯†
        result = engine.execute(applicable[0], context)
        print(f"æ¨èè¡ŒåŠ¨ï¼š{result['knowledge_name']}")
        print(f"å‚æ•°è°ƒæ•´ï¼š{result['parameters']}")
        print(f"é¢„æœŸèŠ‚èƒ½ï¼š{result['expected_outcome']:.1%}")
        print(f"ç½®ä¿¡åº¦ï¼š{result['confidence']:.1%}")
```

### 2.3 çŸ¥è¯†æ›´æ–°æœºåˆ¶

```python
class KnowledgeUpdater:
    """
    åŸºäºå®é™…æ•ˆæœæ›´æ–°çŸ¥è¯†çš„æœ‰æ•ˆæ€§
    """

    def record_execution(self, knowledge_id: str, context: Dict, outcome: Dict):
        """
        è®°å½•çŸ¥è¯†çš„æ‰§è¡Œç»“æœ

        Args:
            knowledge_id: çŸ¥è¯† ID
            context: æ‰§è¡Œæ—¶çš„æƒ…å¢ƒ
            outcome: å®é™…ç»“æœ
                {
                    "success": True/False,
                    "actual_saving": 0.13,  # å®é™…èŠ‚èƒ½ 13%
                    "feedback": "æ•ˆæœå¾ˆå¥½",
                }
        """
        # æ›´æ–°ä½¿ç”¨æ¬¡æ•°
        knowledge = self._get_knowledge(knowledge_id)
        knowledge.usage_count += 1

        # æ›´æ–°æˆåŠŸç‡ï¼ˆæŒ‡æ•°ç§»åŠ¨å¹³å‡ï¼‰
        alpha = 0.1  # å¹³æ»‘ç³»æ•°
        if outcome["success"]:
            knowledge.success_rate = (1 - alpha) * knowledge.success_rate + alpha * 1.0
        else:
            knowledge.success_rate = (1 - alpha) * knowledge.success_rate + alpha * 0.0

        # æ›´æ–°æœ‰æ•ˆæ€§ï¼ˆè€ƒè™‘å®é™…æ•ˆæœ vs é¢„æœŸæ•ˆæœï¼‰
        if "actual_saving" in outcome and "expected_saving" in knowledge.content:
            expected = knowledge.content["expected_saving"]
            actual = outcome["actual_saving"]
            accuracy = min(actual / expected, 1.0) if expected > 0 else 0
            knowledge.effectiveness = (1 - alpha) * knowledge.effectiveness + alpha * accuracy

        # æŒä¹…åŒ–
        self._save_knowledge(knowledge)

    def prune_low_quality(self, threshold: float = 0.5):
        """æ·˜æ±°ä½è´¨é‡çŸ¥è¯†"""
        for k in self.knowledge_base:
            if k.usage_count > 10 and k.effectiveness < threshold:
                k.verified = False
                print(f"æ ‡è®°ä½è´¨é‡çŸ¥è¯†ï¼š{k.name}ï¼ˆæœ‰æ•ˆæ€§ï¼š{k.effectiveness:.2f}ï¼‰")
```

---

## ä¸‰ã€æƒ…å¢ƒçŸ¥è¯†ç®¡ç†

### 3.1 æ•°æ®æ¨¡å‹

```python
@dataclass
class ContextualKnowledge:
    """æƒ…å¢ƒçŸ¥è¯†çš„æ•°æ®ç»“æ„"""

    id: str
    domain: str

    # çŸ¥è¯†å†…å®¹
    title: str
    description: str               # è‡ªç„¶è¯­è¨€æè¿°

    # æƒ…å¢ƒç‰¹å¾
    context_features: Dict[str, Any]  # ç»“æ„åŒ–ç‰¹å¾
    context_embedding: List[float]    # å‘é‡è¡¨ç¤ºï¼ˆç”¨äºç›¸ä¼¼åº¦åŒ¹é…ï¼‰

    # ç»éªŒæ€§çŸ¥è¯†
    diagnosis: str                    # è¯Šæ–­
    action: str                       # æ¨èè¡ŒåŠ¨
    reasoning: str                    # æ¨ç†è¿‡ç¨‹

    # æ¥æºä¸éªŒè¯
    source_expert: str                # æ¥æºä¸“å®¶
    validation_count: int             # è¢«éªŒè¯æ¬¡æ•°
    validation_success_rate: float    # éªŒè¯æˆåŠŸç‡

    # å…ƒæ•°æ®
    created_at: str
    updated_at: str


# ç¤ºä¾‹ï¼šè€å¸ˆå‚…çš„ç»éªŒ
example_contextual = ContextualKnowledge(
    id="ctx_hvac_001",
    domain="HVAC",

    title="å‹ç¼©æœºè½´æ‰¿ç£¨æŸçš„æ—©æœŸå¾å…†",
    description="å½“å‹ç¼©æœºå¯åŠ¨ç”µæµæ³¢åŠ¨è¶…è¿‡ 5%ï¼Œä¸”è¿è¡Œå£°éŸ³é¢‘ç‡åç§»è¶…è¿‡ 2Hzï¼Œè™½ç„¶æ¸©åº¦æ§åˆ¶ä»ç„¶æ­£å¸¸ï¼Œä½†è¿™é€šå¸¸æ˜¯è½´æ‰¿ç£¨æŸçš„æ—©æœŸå¾å…†",

    context_features={
        "symptom_current_fluctuation": "> 5%",
        "symptom_sound_frequency_shift": "> 2Hz",
        "symptom_temp_control": "normal",
        "equipment_type": "compressor",
        "equipment_age": "> 3 years"
    },

    context_embedding=[0.23, -0.45, 0.67, ...],  # 768 ç»´å‘é‡

    diagnosis="å‹ç¼©æœºè½´æ‰¿ç£¨æŸï¼ˆæ—©æœŸï¼‰",
    action="å»ºè®® 2 å‘¨å†…å®‰æ’æ›´æ¢",
    reasoning="è½´æ‰¿ç£¨æŸä¼šå¯¼è‡´è½¬è½´ä¸ç¨³å®šï¼Œè¡¨ç°ä¸ºç”µæµæ³¢åŠ¨å’Œå£°éŸ³å¼‚å¸¸ï¼Œä½†çŸ­æœŸå†…ä¸å½±å“æ¸©åº¦æ§åˆ¶ã€‚å¦‚æœä¸åŠæ—¶å¤„ç†ï¼Œ2-4 å‘¨åå¯èƒ½çªç„¶æ•…éšœã€‚",

    source_expert="å¼ å¸ˆå‚…ï¼ˆ20 å¹´ç»éªŒï¼‰",
    validation_count=15,
    validation_success_rate=0.87,

    created_at="2024-08-10",
    updated_at="2025-01-15"
)
```

### 3.2 æƒ…å¢ƒåŒ¹é…å¼•æ“ï¼ˆRAGï¼‰

```python
from typing import List
import numpy as np

class ContextMatcher:
    """
    åŸºäº RAG (Retrieval-Augmented Generation) çš„æƒ…å¢ƒçŸ¥è¯†åŒ¹é…
    """

    def __init__(self, knowledge_base: List[ContextualKnowledge], embedding_model):
        self.knowledge_base = knowledge_base
        self.embedding_model = embedding_model

        # æ„å»ºå‘é‡ç´¢å¼•ï¼ˆä½¿ç”¨ FAISS / Pinecone / Qdrantï¼‰
        self.vector_index = self._build_vector_index()

    def _build_vector_index(self):
        """æ„å»ºå‘é‡ç´¢å¼•ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼Œç”Ÿäº§ç¯å¢ƒä½¿ç”¨ FAISSï¼‰"""
        embeddings = [k.context_embedding for k in self.knowledge_base]
        return np.array(embeddings)

    def find_similar_contexts(self, current_situation: str, top_k: int = 5) -> List[ContextualKnowledge]:
        """
        æ‰¾åˆ°ä¸å½“å‰æƒ…å¢ƒç›¸ä¼¼çš„å†å²æƒ…å¢ƒ

        Args:
            current_situation: å½“å‰æƒ…å¢ƒçš„è‡ªç„¶è¯­è¨€æè¿°
                ä¾‹å¦‚ï¼š"å‹ç¼©æœºå¯åŠ¨æ—¶ç”µæµæ³¢åŠ¨ 6%ï¼Œå£°éŸ³é¢‘ç‡åç§» 3Hzï¼Œä½†æ¸©åº¦æ§åˆ¶æ­£å¸¸"
            top_k: è¿”å›æœ€ç›¸ä¼¼çš„ k ä¸ª

        Returns:
            ç›¸ä¼¼æƒ…å¢ƒçš„çŸ¥è¯†åˆ—è¡¨
        """
        # 1. å°†å½“å‰æƒ…å¢ƒç¼–ç ä¸ºå‘é‡
        current_embedding = self.embedding_model.encode(current_situation)

        # 2. è®¡ç®—ç›¸ä¼¼åº¦
        similarities = np.dot(self.vector_index, current_embedding)

        # 3. è¿”å› top-k
        top_indices = np.argsort(similarities)[-top_k:][::-1]

        results = []
        for idx in top_indices:
            k = self.knowledge_base[idx]
            results.append({
                "knowledge": k,
                "similarity": similarities[idx],
                "confidence": k.validation_success_rate
            })

        return results

    def generate_recommendation(self, current_situation: str, llm) -> Dict[str, Any]:
        """
        ç”Ÿæˆæ¨èï¼ˆRAG æ¨¡å¼ï¼‰

        Steps:
            1. Retrieval: æ£€ç´¢ç›¸ä¼¼æƒ…å¢ƒ
            2. Augmentation: æ„å»ºå¢å¼ºæç¤ºè¯
            3. Generation: LLM ç”Ÿæˆæ¨è
        """
        # 1. Retrieval
        similar = self.find_similar_contexts(current_situation, top_k=3)

        # 2. Augmentation
        prompt = f"""
ä½ æ˜¯ä¸€ä¸ª HVAC é¢†åŸŸçš„ä¸“å®¶ã€‚ç°åœ¨é‡åˆ°ä»¥ä¸‹æƒ…å†µï¼š

**å½“å‰æƒ…å¢ƒ**ï¼š
{current_situation}

**ç›¸ä¼¼çš„å†å²æ¡ˆä¾‹**ï¼š

"""
        for i, item in enumerate(similar, 1):
            k = item["knowledge"]
            prompt += f"""
æ¡ˆä¾‹ {i}ï¼ˆç›¸ä¼¼åº¦ï¼š{item["similarity"]:.2f}ï¼Œå¯ä¿¡åº¦ï¼š{item["confidence"]:.2f}ï¼‰ï¼š
- æƒ…å¢ƒï¼š{k.description}
- è¯Šæ–­ï¼š{k.diagnosis}
- æ¨èè¡ŒåŠ¨ï¼š{k.action}
- æ¨ç†ï¼š{k.reasoning}
- æ¥æºï¼š{k.source_expert}

"""

        prompt += """
**ä»»åŠ¡**ï¼š
åŸºäºä»¥ä¸Šå†å²æ¡ˆä¾‹ï¼Œå¯¹å½“å‰æƒ…å¢ƒè¿›è¡Œï¼š
1. è¯Šæ–­ï¼ˆæœ€å¯èƒ½çš„é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿï¼‰
2. æ¨èè¡ŒåŠ¨ï¼ˆåº”è¯¥æ€ä¹ˆåšï¼Ÿï¼‰
3. æ¨ç†è¿‡ç¨‹ï¼ˆä¸ºä»€ä¹ˆè¿™æ ·åˆ¤æ–­ï¼Ÿï¼‰
4. ç½®ä¿¡åº¦ï¼ˆ0-100%ï¼‰
"""

        # 3. Generation
        response = llm.generate(prompt)

        return {
            "diagnosis": response["diagnosis"],
            "action": response["action"],
            "reasoning": response["reasoning"],
            "confidence": response["confidence"],
            "similar_cases": [item["knowledge"].id for item in similar]
        }
```

### 3.3 ç»éªŒæ²‰æ·€æœºåˆ¶

```python
class ExperienceCapture:
    """
    åœ¨å·¥ä½œæµä¸­æ•è·ä¸“å®¶çš„æƒ…å¢ƒçŸ¥è¯†
    """

    def capture_from_interaction(self, interaction: Dict) -> ContextualKnowledge:
        """
        ä»ä¸“å®¶ä¸ç³»ç»Ÿçš„äº¤äº’ä¸­æå–æƒ…å¢ƒçŸ¥è¯†

        Args:
            interaction: äº¤äº’è®°å½•
                {
                    "situation": "å‹ç¼©æœºå¯åŠ¨æ—¶...",
                    "expert_diagnosis": "è½´æ‰¿ç£¨æŸ",
                    "expert_action": "å»ºè®®æ›´æ¢",
                    "expert_reasoning": "å› ä¸º...",
                    "outcome": {"success": True, ...}
                }
        """
        # 1. è‡ªç„¶è¯­è¨€ â†’ ç»“æ„åŒ–ç‰¹å¾
        features = self._extract_features(interaction["situation"])

        # 2. ç”Ÿæˆå‘é‡è¡¨ç¤º
        embedding = self.embedding_model.encode(interaction["situation"])

        # 3. åˆ›å»ºæƒ…å¢ƒçŸ¥è¯†
        knowledge = ContextualKnowledge(
            id=self._generate_id(),
            domain="HVAC",
            title=self._generate_title(interaction),
            description=interaction["situation"],
            context_features=features,
            context_embedding=embedding,
            diagnosis=interaction["expert_diagnosis"],
            action=interaction["expert_action"],
            reasoning=interaction["expert_reasoning"],
            source_expert=interaction["expert_id"],
            validation_count=1,
            validation_success_rate=1.0 if interaction["outcome"]["success"] else 0.0,
            created_at=datetime.now().isoformat(),
            updated_at=datetime.now().isoformat()
        )

        return knowledge

    def _extract_features(self, situation_text: str) -> Dict:
        """ä½¿ç”¨ NLP æå–ç»“æ„åŒ–ç‰¹å¾"""
        # ä½¿ç”¨ LLM è¿›è¡Œä¿¡æ¯æŠ½å–
        prompt = f"""
ä»ä»¥ä¸‹æè¿°ä¸­æå–å…³é”®ç‰¹å¾ï¼š

{situation_text}

è¯·ä»¥ JSON æ ¼å¼è¿”å›ï¼š
{{
    "equipment_type": "...",
    "symptoms": ["...", "..."],
    "parameters": {{"key": "value"}},
    ...
}}
"""
        return llm_extract(prompt)
```

---

## å››ã€å…ƒå±‚çŸ¥è¯†ç®¡ç†

### 4.1 æ•°æ®æ¨¡å‹

```python
@dataclass
class MetaKnowledge:
    """å…ƒå±‚çŸ¥è¯†ï¼ˆæ´å¯Ÿï¼‰çš„æ•°æ®ç»“æ„"""

    id: str

    # æ´å¯Ÿå†…å®¹
    title: str
    insight: str                      # æ ¸å¿ƒæ´å¯Ÿ
    evidence: List[str]               # æ”¯æ’‘è¯æ®
    implications: List[str]           # æˆ˜ç•¥å«ä¹‰

    # å½±å“èŒƒå›´
    scales_affected: Dict[str, str]   # å½±å“çš„å°ºåº¦
        # {
        #     "abstraction": "ä»'å¦‚ä½•ä¼˜åŒ–å‚æ•°'åˆ°'æ˜¯å¦åº”è¯¥ä¼˜åŒ–å‚æ•°'",
        #     "time": "ä»'çŸ­æœŸèŠ‚èƒ½'åˆ°'é•¿æœŸè®¾å¤‡å¯¿å‘½'",
        #     "scope": "ä»'å•ä¸ªå®¢æˆ·'åˆ°'æ•´ä¸ªè¡Œä¸š'"
        # }

    # ä»·å€¼æ•°æ®
    value_created: float              # åˆ›é€ çš„å•†ä¸šä»·å€¼ï¼ˆ$ï¼‰
    usage_count: int                  # è¢«ä½¿ç”¨æ¬¡æ•°
    customer_impact: List[str]        # å½±å“çš„å®¢æˆ· ID

    # æ¥æº
    source_expert: str
    source_data: List[str]            # æ”¯æ’‘æ•°æ®æ¥æº
    created_at: str

    # çŠ¶æ€
    status: str                       # "draft", "validated", "published"
    validation_notes: List[str]


# ç¤ºä¾‹ï¼šå…ƒå±‚æ´å¯Ÿ
example_meta = MetaKnowledge(
    id="meta_hvac_001",

    title="HVAC è¡Œä¸šçš„çœŸæ­£ç—›ç‚¹æ˜¯æ•…éšœé¢„æµ‹ï¼Œè€Œéèƒ½æ•ˆä¼˜åŒ–",

    insight="""
è¡Œä¸šæ™®éè®¤ä¸º HVAC çš„æ ¸å¿ƒé—®é¢˜æ˜¯èƒ½æ•ˆï¼Œä½†é€šè¿‡ 200 ä¸ªå®¢æˆ·è®¿è°ˆå‘ç°ï¼š
1. èƒ½è€—æˆæœ¬å æ€»æˆæœ¬ < 15%
2. æ•…éšœå¯¼è‡´çš„åœæœºæŸå¤± > èƒ½è€—æˆæœ¬ 3 å€
3. å®¢æˆ·æ„¿æ„ä¸º"é›¶æ•…éšœ"æ”¯ä»˜ 20% æº¢ä»·

å› æ­¤ï¼Œåº”è¯¥é‡æ–°å®šä½äº§å“ï¼Œä»"èƒ½æ•ˆä¼˜åŒ–"è½¬å‘"æ•…éšœé¢„æµ‹"ã€‚
""",

    evidence=[
        "200 ä¸ªå®¢æˆ·è®¿è°ˆæ•°æ®",
        "50 ä¸ªå®¢æˆ·çš„æˆæœ¬ç»“æ„åˆ†æ",
        "3 ä¸ªæ ‡æ†å®¢æˆ·çš„æ¡ˆä¾‹ç ”ç©¶",
        "è¡Œä¸šæŠ¥å‘Šï¼šæ•…éšœåœæœºå¹´å‡æŸå¤± $XX"
    ],

    implications=[
        "äº§å“å®šä½ï¼šä»'çœé’±'åˆ°'é¿å…æŸå¤±'",
        "é”€å”®è¯æœ¯ï¼šå¼ºè°ƒ'é›¶æ•…éšœ'è€Œé'èŠ‚èƒ½'",
        "ç ”å‘é‡ç‚¹ï¼šæŠ•å…¥æ•…éšœé¢„æµ‹ç®—æ³•",
        "å®šä»·ç­–ç•¥ï¼šæŒ‰'é¿å…çš„æŸå¤±'æ”¶è´¹ï¼Œè€ŒéæŒ‰è®¾å¤‡æ•°"
    ],

    scales_affected={
        "abstraction": "ä»'å¦‚ä½•ä¼˜åŒ–èƒ½è€—'åˆ°'ä»€ä¹ˆæ˜¯çœŸæ­£çš„ç—›ç‚¹'",
        "time": "ä»'çŸ­æœŸèŠ‚èƒ½'åˆ°'é•¿æœŸä¸šåŠ¡æˆ˜ç•¥'",
        "scope": "ä»'å•ä¸ªå®¢æˆ·'åˆ°'æ•´ä¸ªè¡Œä¸š'"
    },

    value_created=10_000_000.0,  # $10M
    usage_count=23,
    customer_impact=["customer_001", "customer_005", ...],

    source_expert="æå·¥ï¼ˆ15 å¹´è¡Œä¸šç»éªŒï¼‰",
    source_data=[
        "interview_data_2025q1.csv",
        "cost_analysis_50_customers.xlsx",
        "case_study_customer_A.pdf"
    ],
    created_at="2025-01-15",

    status="validated",
    validation_notes=[
        "2025-02-01: åœ¨å®¢æˆ· A éªŒè¯ï¼ŒåˆåŒé‡‘é¢å¢åŠ  40%",
        "2025-02-15: åœ¨å®¢æˆ· B éªŒè¯ï¼Œç»­çº¦ç‡æå‡",
        "2025-03-01: å‘å¸ƒåˆ°å¹³å°"
    ]
)
```

### 4.2 æ´å¯Ÿæ•è·ç³»ç»Ÿ

```python
class InsightCapture:
    """
    æ•è·ä¸“å®¶çš„å…ƒå±‚æ´å¯Ÿ
    """

    def initiate_capture(self, trigger: str) -> Dict:
        """
        å¯åŠ¨æ´å¯Ÿæ•è·æµç¨‹

        Args:
            trigger: è§¦å‘åœºæ™¯
                - "expert_question": ä¸“å®¶æå‡ºäº†å¥½é—®é¢˜
                - "pattern_discovery": å‘ç°äº†åå¤å‡ºç°çš„æ¨¡å¼
                - "client_feedback": å®¢æˆ·åé¦ˆæš´éœ²äº†è¯¯è§£
        """
        # å±•ç¤ºå¼•å¯¼å¼è¡¨å•
        return {
            "questions": [
                "ä½ åˆšæ‰çš„æ´å¯Ÿæ˜¯ä»€ä¹ˆï¼Ÿï¼ˆä¸€å¥è¯ï¼‰",
                "ä¸ºä»€ä¹ˆè¿™å¾ˆé‡è¦ï¼Ÿ",
                "æœ‰ä»€ä¹ˆè¯æ®æ”¯æŒï¼Ÿ",
                "è¿™ä¸ªæ´å¯Ÿä¼šå¦‚ä½•æ”¹å˜æˆ‘ä»¬çš„ç­–ç•¥ï¼Ÿ",
                "è¿™å½±å“å“ªäº›å°ºåº¦ï¼Ÿï¼ˆæ—¶é—´/ç©ºé—´/æŠ½è±¡ï¼‰"
            ],
            "examples": [example_meta],  # å±•ç¤ºç¤ºä¾‹
            "assistance": "AI ä¼šå¸®ä½ æ•´ç†å’Œç»“æ„åŒ–ä½ çš„æƒ³æ³•"
        }

    def process_expert_input(self, raw_input: Dict) -> MetaKnowledge:
        """
        å¤„ç†ä¸“å®¶è¾“å…¥ï¼Œç”Ÿæˆç»“æ„åŒ–æ´å¯Ÿ
        """
        # 1. ä½¿ç”¨ LLM å¸®åŠ©ç»“æ„åŒ–
        prompt = f"""
ä¸€ä½é¢†åŸŸä¸“å®¶æå‡ºäº†ä»¥ä¸‹æ´å¯Ÿï¼š

{raw_input["insight_text"]}

è¯·å¸®åŠ©ç»“æ„åŒ–è¿™ä¸ªæ´å¯Ÿï¼š
1. æç‚¼æ ¸å¿ƒè§‚ç‚¹ï¼ˆ1-2 å¥ï¼‰
2. è¯†åˆ«æ”¯æ’‘è¯æ®
3. æ¨æ–­æˆ˜ç•¥å«ä¹‰
4. åˆ†æå½±å“çš„å°ºåº¦

ä»¥ JSON æ ¼å¼è¿”å›ã€‚
"""
        structured = llm_structure(prompt)

        # 2. åˆ›å»ºå…ƒå±‚çŸ¥è¯†å¯¹è±¡
        meta = MetaKnowledge(
            id=self._generate_id(),
            title=structured["title"],
            insight=structured["core_insight"],
            evidence=structured["evidence"],
            implications=structured["implications"],
            scales_affected=structured["scales"],
            value_created=0.0,  # åˆå§‹ä¸º 0ï¼Œåç»­è·Ÿè¸ª
            usage_count=0,
            customer_impact=[],
            source_expert=raw_input["expert_id"],
            source_data=raw_input.get("data_sources", []),
            created_at=datetime.now().isoformat(),
            status="draft",
            validation_notes=[]
        )

        return meta

    def suggest_insights(self, context: Dict) -> List[str]:
        """
        AI ä¸»åŠ¨å»ºè®®ï¼š"ä½ åˆšæ‰çš„æ€è€ƒå¯èƒ½æ˜¯ä¸€ä¸ªæ´å¯Ÿ"
        """
        # æ£€æµ‹å…ƒå±‚æ€è€ƒçš„ä¿¡å·
        signals = [
            "è´¨ç–‘æ¡†æ¶"ï¼šä¸“å®¶è¯´äº†"ä¹Ÿè®¸æˆ‘ä»¬é—®é”™äº†é—®é¢˜"
            "å°ºåº¦åˆ‡æ¢"ï¼šä¸“å®¶ä»ç»†èŠ‚è·³åˆ°äº†åŸåˆ™
            "æ¨¡å¼è¯†åˆ«"ï¼šä¸“å®¶è¯´äº†"æˆ‘æ³¨æ„åˆ°ä¸€ä¸ªè§„å¾‹"
        ]

        if self._detect_meta_thinking(context):
            return [
                "ä½ åˆšæ‰æå‡ºçš„è§‚ç‚¹å¯èƒ½æ˜¯ä¸€ä¸ªé‡è¦æ´å¯Ÿï¼",
                "è¦ä¸è¦èŠ± 2 åˆ†é’Ÿè®°å½•ä¸‹æ¥ï¼Ÿ",
                "è¿™å¯èƒ½å¸®åŠ©åˆ°å…¶ä»–å®¢æˆ·ï¼Œä¹Ÿèƒ½ä¸ºä½ å¸¦æ¥æ”¶ç›Šã€‚"
            ]
```

### 4.3 æ´å¯Ÿæ‰§è¡Œç³»ç»Ÿ

```python
class InsightExecutor:
    """
    è®© AI æ‰§è¡Œå…ƒå±‚æ´å¯Ÿ
    """

    def apply_insight(self, insight: MetaKnowledge, context: Dict) -> Dict:
        """
        å°†æ´å¯Ÿåº”ç”¨åˆ°å…·ä½“å†³ç­–ä¸­

        Args:
            insight: å…ƒå±‚æ´å¯Ÿ
            context: å½“å‰å†³ç­–æƒ…å¢ƒ

        Returns:
            ä¿®æ”¹åçš„å†³ç­–å»ºè®®
        """
        # æ„å»ºæç¤ºè¯
        prompt = f"""
ä½ æ­£åœ¨å¸®åŠ©å®¢æˆ·åšä¸€ä¸ªå…³äº {context["decision_topic"]} çš„å†³ç­–ã€‚

ä½†æ˜¯ï¼Œæœ‰ä¸€ä¸ªé‡è¦çš„æ´å¯Ÿéœ€è¦è€ƒè™‘ï¼š

**æ´å¯Ÿ**ï¼š{insight.title}
{insight.insight}

**æˆ˜ç•¥å«ä¹‰**ï¼š
{chr(10).join('- ' + imp for imp in insight.implications)}

**ä»»åŠ¡**ï¼š
åŸºäºè¿™ä¸ªæ´å¯Ÿï¼Œé‡æ–°å®¡è§†å½“å‰å†³ç­–ï¼š
1. å½“å‰å†³ç­–æ˜¯å¦å¯¹é½è¿™ä¸ªæ´å¯Ÿï¼Ÿ
2. æ˜¯å¦åº”è¯¥è°ƒæ•´å†³ç­–ï¼Ÿ
3. å¦‚æœè°ƒæ•´ï¼Œå¦‚ä½•è°ƒæ•´ï¼Ÿ

å½“å‰å†³ç­–è‰æ¡ˆï¼š
{context["draft_decision"]}

è¯·æä¾›ï¼š
1. æ´å¯Ÿç›¸å…³æ€§ï¼ˆæ˜¯å¦é€‚ç”¨äºå½“å‰å†³ç­–ï¼‰
2. è°ƒæ•´å»ºè®®
3. è°ƒæ•´ç†ç”±
"""

        response = llm_execute(prompt)

        return {
            "insight_id": insight.id,
            "relevance": response["relevance"],
            "adjustment": response["adjustment"],
            "reasoning": response["reasoning"]
        }

    def execute_with_insights(self, decision_context: Dict, insight_library: List[MetaKnowledge]) -> Dict:
        """
        åœ¨æ‰€æœ‰ç›¸å…³æ´å¯Ÿçš„æŒ‡å¯¼ä¸‹æ‰§è¡Œå†³ç­–
        """
        # 1. æ‰¾åˆ°ç›¸å…³æ´å¯Ÿ
        relevant_insights = self._find_relevant_insights(decision_context, insight_library)

        # 2. å¯¹æ¯ä¸ªæ´å¯Ÿï¼Œç”Ÿæˆè°ƒæ•´å»ºè®®
        adjustments = []
        for insight in relevant_insights:
            adj = self.apply_insight(insight, decision_context)
            if adj["relevance"] > 0.7:  # é«˜ç›¸å…³æ€§
                adjustments.append(adj)

        # 3. ç»¼åˆè°ƒæ•´
        final_decision = self._synthesize_adjustments(
            original=decision_context["draft_decision"],
            adjustments=adjustments
        )

        return {
            "original_decision": decision_context["draft_decision"],
            "final_decision": final_decision,
            "applied_insights": [adj["insight_id"] for adj in adjustments],
            "reasoning": self._generate_explanation(adjustments)
        }
```

---

## äº”ã€ç¼©æ”¾æç¤ºå¼•æ“

### 5.1 å°ºåº¦æ£€æµ‹

```python
class ScaleDetector:
    """
    æ£€æµ‹å†³ç­–ä¸­éšå«çš„å°ºåº¦
    """

    def detect_scales(self, decision_text: str) -> Dict[str, str]:
        """
        æ£€æµ‹å†³ç­–æ–‡æœ¬ä¸­éšå«çš„å°ºåº¦

        Returns:
            {
                "time": "short_term",       # short_term / medium_term / long_term
                "scope": "individual",      # individual / team / company / industry
                "abstraction": "detail",    # detail / rule / principle / philosophy
                "stakeholder": "user"       # user / team / business / society
            }
        """
        prompt = f"""
åˆ†æä»¥ä¸‹å†³ç­–ä¸­éšå«çš„æ€è€ƒå°ºåº¦ï¼š

å†³ç­–ï¼š{decision_text}

è¯·è¯†åˆ«ï¼š
1. æ—¶é—´å°ºåº¦ï¼šå…³æ³¨çš„æ˜¯çŸ­æœŸï¼ˆ< 1 æœˆï¼‰ã€ä¸­æœŸï¼ˆ1-12 æœˆï¼‰ã€é•¿æœŸï¼ˆ> 1 å¹´ï¼‰ï¼Ÿ
2. ç©ºé—´èŒƒå›´ï¼šå…³æ³¨çš„æ˜¯ä¸ªä½“ã€å›¢é˜Ÿã€å…¬å¸ã€è¡Œä¸šã€ç¤¾ä¼šï¼Ÿ
3. æŠ½è±¡å±‚çº§ï¼šåœ¨è®¨è®ºç»†èŠ‚ã€è§„åˆ™ã€åŸåˆ™ã€è¿˜æ˜¯å“²å­¦ï¼Ÿ
4. åˆ©ç›Šç›¸å…³æ–¹ï¼šä¸»è¦è€ƒè™‘ç”¨æˆ·ã€å›¢é˜Ÿã€ä¸šåŠ¡ã€è¿˜æ˜¯ç¤¾ä¼šï¼Ÿ

ä»¥ JSON æ ¼å¼è¿”å›ã€‚
"""
        return llm_analyze(prompt)


class ScaleReminderEngine:
    """
    ç¼©æ”¾æç¤ºå¼•æ“ï¼šæé†’è¢«å¿½è§†çš„å°ºåº¦
    ï¼ˆè¯¦è§ architecture.md ç¬¬ 3.2 èŠ‚ï¼‰
    """

    def __init__(self, detector: ScaleDetector):
        self.detector = detector

    def generate_reminders(self, decision: Dict) -> List[Dict]:
        """
        ç”Ÿæˆå°ºåº¦æé†’

        Args:
            decision: {
                "text": "æˆ‘ä»¬åº”è¯¥ä¼˜åŒ–è¿™ä¸ªå‚æ•°æ¥çœç”µ",
                "context": {...}
            }

        Returns:
            æé†’åˆ—è¡¨
        """
        # 1. æ£€æµ‹å½“å‰å°ºåº¦
        current_scales = self.detector.detect_scales(decision["text"])

        # 2. ç”Ÿæˆå…¶ä»–å°ºåº¦çš„æé†’
        reminders = []

        # æ—¶é—´å°ºåº¦æé†’
        if current_scales["time"] == "short_term":
            reminders.append({
                "type": "time_scale",
                "current": "çŸ­æœŸï¼ˆçœç”µï¼‰",
                "reminder": "é•¿æœŸå°ºåº¦",
                "message": "ä¼˜åŒ–è¿™ä¸ªå‚æ•°çŸ­æœŸèƒ½çœç”µ 10%ï¼Œä½†é•¿æœŸå¯èƒ½å¯¼è‡´è®¾å¤‡ç£¨æŸåŠ å¿«ï¼Œ3 å¹´åç»´æŠ¤æˆæœ¬å¢åŠ  30%ã€‚æ˜¯å¦è€ƒè™‘é•¿æœŸæƒè¡¡ï¼Ÿ"
            })

        # æŠ½è±¡å±‚çº§æé†’
        if current_scales["abstraction"] == "detail":
            reminders.append({
                "type": "abstraction_scale",
                "current": "ç»†èŠ‚ï¼ˆå‚æ•°ä¼˜åŒ–ï¼‰",
                "reminder": "åŸåˆ™å±‚é¢",
                "message": "åœ¨ç»†èŠ‚å±‚é¢ï¼Œæˆ‘ä»¬åœ¨ä¼˜åŒ–å‚æ•°ï¼›ä½†åœ¨åŸåˆ™å±‚é¢ï¼Œä¹Ÿè®¸åº”è¯¥é—®ï¼š'å®¢æˆ·çœŸæ­£åœ¨ä¹çš„æ˜¯çœç”µï¼Œè¿˜æ˜¯èˆ’é€‚åº¦ï¼Ÿ'åˆ‡æ¢åˆ°åŸåˆ™å±‚é¢æ€è€ƒå¯èƒ½å‘ç°ä¸åŒçš„è§£å†³æ–¹æ¡ˆã€‚"
            })

        # åˆ©ç›Šç›¸å…³æ–¹æé†’
        if current_scales["stakeholder"] == "user":
            reminders.append({
                "type": "stakeholder_scale",
                "current": "ç”¨æˆ·è§†è§’",
                "reminder": "ä¸šåŠ¡è§†è§’",
                "message": "ä»ç”¨æˆ·è§†è§’ï¼Œçœç”µæ˜¯å¥½çš„ï¼›ä½†ä»ä¸šåŠ¡è§†è§’ï¼Œè¿™å¯èƒ½é™ä½æˆ‘ä»¬çš„è€—æé”€å”®æ”¶å…¥ã€‚æ˜¯å¦éœ€è¦å¹³è¡¡ï¼Ÿ"
            })

        return reminders

    def present_reminders(self, reminders: List[Dict], ui_context: str) -> Dict:
        """
        å†³å®šä½•æ—¶ã€å¦‚ä½•å±•ç¤ºæé†’

        Args:
            ui_context: "before_decision" / "after_decision" / "review"

        Returns:
            å±•ç¤ºç­–ç•¥
        """
        if ui_context == "before_decision":
            # å†³ç­–å‰ï¼šä¸»åŠ¨ä»‹å…¥ï¼Œä½†ä¸è¦æ‰“æ–­
            return {
                "timing": "show_as_suggestion",
                "style": "gentle",
                "message": "ğŸ’¡ åœ¨åšæœ€ç»ˆå†³å®šå‰ï¼Œä¹Ÿè®¸å¯ä»¥ä»å…¶ä»–å°ºåº¦è€ƒè™‘ä¸€ä¸‹ï¼Ÿ"
            }
        elif ui_context == "after_decision":
            # å†³ç­–åï¼šä½œä¸ºåæ€
            return {
                "timing": "show_in_review",
                "style": "reflective",
                "message": "å›é¡¾ä¸€ä¸‹ï¼Œå¦‚æœä»è¿™äº›å°ºåº¦æ€è€ƒï¼Œä¼šæœ‰ä¸åŒçš„å†³ç­–å—ï¼Ÿ"
            }
```

### 5.2 é›†æˆåˆ°å·¥ä½œæµ

```python
# å·¥ä½œæµç¤ºä¾‹
class DecisionWorkflow:
    """
    é›†æˆç¼©æ”¾æç¤ºçš„å†³ç­–å·¥ä½œæµ
    """

    def __init__(self):
        self.scale_reminder = ScaleReminderEngine(ScaleDetector())
        self.insight_executor = InsightExecutor()

    def run(self, user_input: Dict):
        """
        æ‰§è¡Œå†³ç­–å·¥ä½œæµ
        """
        # 1. ç”¨æˆ·è¾“å…¥å†³ç­–è‰æ¡ˆ
        draft_decision = user_input["decision"]

        # 2. ç”Ÿæˆå°ºåº¦æé†’
        reminders = self.scale_reminder.generate_reminders({
            "text": draft_decision,
            "context": user_input.get("context", {})
        })

        # 3. å±•ç¤ºæé†’ï¼Œè®©ç”¨æˆ·é€‰æ‹©æ˜¯å¦åˆ‡æ¢å°ºåº¦
        if reminders:
            print("ğŸ’¡ ä¹Ÿè®¸å¯ä»¥ä»å…¶ä»–å°ºåº¦è€ƒè™‘ï¼š")
            for r in reminders:
                print(f"   - {r['message']}")

            user_choice = input("è¦åˆ‡æ¢å°ºåº¦é‡æ–°æ€è€ƒå—ï¼Ÿ(y/n)")

            if user_choice == 'y':
                # ç”¨æˆ·é€‰æ‹©åˆ‡æ¢å°ºåº¦ï¼ŒAI è¾…åŠ©é‡æ–°æ€è€ƒ
                refined_decision = self._rethink_at_scale(draft_decision, reminders)
            else:
                refined_decision = draft_decision
        else:
            refined_decision = draft_decision

        # 4. åº”ç”¨å…ƒå±‚æ´å¯Ÿ
        final_decision = self.insight_executor.execute_with_insights(
            decision_context={"draft_decision": refined_decision},
            insight_library=self._load_insights()
        )

        return final_decision
```

---

## å…­ã€çŸ¥è¯†é£è½®æŠ€æœ¯å®ç°

### 6.1 çŸ¥è¯†è´¡çŒ®è¿½è¸ª

```python
class KnowledgeContributionTracker:
    """
    è¿½è¸ªçŸ¥è¯†çš„è´¡çŒ®å’Œä»·å€¼åˆ›é€ 
    """

    def track_usage(self, knowledge_id: str, user_id: str, outcome: Dict):
        """
        è¿½è¸ªçŸ¥è¯†ä½¿ç”¨å’Œæ•ˆæœ
        """
        event = {
            "knowledge_id": knowledge_id,
            "user_id": user_id,
            "timestamp": datetime.now().isoformat(),
            "outcome": outcome,  # {"success": True, "value_created": 5000}
        }

        self._log_event(event)

        # æ›´æ–°çŸ¥è¯†çš„ä»·å€¼ç»Ÿè®¡
        self._update_knowledge_value(knowledge_id, outcome.get("value_created", 0))

    def calculate_contributor_revenue(self, contributor_id: str, period: str) -> float:
        """
        è®¡ç®—è´¡çŒ®è€…åœ¨æŒ‡å®šå‘¨æœŸçš„æ”¶ç›Š
        """
        # æŸ¥è¯¢è¯¥è´¡çŒ®è€…çš„çŸ¥è¯†è¢«ä½¿ç”¨æƒ…å†µ
        contributions = self._get_contributions(contributor_id)

        total_revenue = 0.0
        for k in contributions:
            # çŸ¥è¯†åˆ›é€ çš„ä»·å€¼
            value_created = k.value_created

            # åˆ†æˆæ¯”ä¾‹ï¼ˆä¾‹å¦‚ 30%ï¼‰
            revenue_share = 0.30

            # è´¡çŒ®è€…æ”¶ç›Š
            contributor_revenue = value_created * revenue_share
            total_revenue += contributor_revenue

        return total_revenue
```

### 6.2 çŸ¥è¯†æ¨èç³»ç»Ÿ

```python
class KnowledgeRecommender:
    """
    å‘ç”¨æˆ·æ¨èç›¸å…³çŸ¥è¯†
    """

    def recommend(self, user_context: Dict, top_k: int = 3) -> List[Dict]:
        """
        åŸºäºç”¨æˆ·å½“å‰æƒ…å¢ƒæ¨èçŸ¥è¯†
        """
        # 1. ç†è§£ç”¨æˆ·æƒ…å¢ƒ
        context_embedding = self._embed_context(user_context)

        # 2. æ£€ç´¢ç›¸å…³çŸ¥è¯†ï¼ˆå¯ç¼–ç  + æƒ…å¢ƒ + å…ƒå±‚ï¼‰
        candidates = []

        # å¯ç¼–ç çŸ¥è¯†
        codifiable = self._search_codifiable(user_context)
        candidates.extend([{"type": "codifiable", "knowledge": k} for k in codifiable])

        # æƒ…å¢ƒçŸ¥è¯†
        contextual = self._search_contextual(context_embedding)
        candidates.extend([{"type": "contextual", "knowledge": k} for k in contextual])

        # å…ƒå±‚çŸ¥è¯†
        meta = self._search_meta(user_context)
        candidates.extend([{"type": "meta", "knowledge": k} for k in meta])

        # 3. æ’åºï¼ˆæŒ‰ç›¸å…³æ€§ Ã— è´¨é‡ Ã— æ–°é²œåº¦ï¼‰
        ranked = self._rank_candidates(candidates, user_context)

        return ranked[:top_k]

    def _rank_candidates(self, candidates, context):
        """ç»¼åˆæ’åº"""
        for c in candidates:
            k = c["knowledge"]
            score = (
                0.4 * self._relevance_score(k, context) +
                0.3 * self._quality_score(k) +
                0.2 * self._freshness_score(k) +
                0.1 * self._diversity_score(k, candidates)
            )
            c["score"] = score

        return sorted(candidates, key=lambda x: x["score"], reverse=True)
```

---

## ä¸ƒã€éƒ¨ç½²æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Web UI (React)                    â”‚
â”‚  - Workbench (ç”¨æˆ·å·¥ä½œå°)                              â”‚
â”‚  - çŸ¥è¯†æ•è·è¡¨å•                                         â”‚
â”‚  - ç¼©æ”¾æç¤ºå±•ç¤º                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚ API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Backend Services (Python)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Rule Engine â”‚  â”‚ RAG Pipeline â”‚  â”‚ Insight Mgr â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Scale       â”‚  â”‚ Knowledge    â”‚  â”‚ Contributionâ”‚ â”‚
â”‚  â”‚ Reminder    â”‚  â”‚ Recommender  â”‚  â”‚ Tracker     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Data Layer                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ PostgreSQL   â”‚  â”‚ Vector DB     â”‚  â”‚ Graph DB  â”‚ â”‚
â”‚  â”‚ (å…³ç³»æ•°æ®)    â”‚  â”‚ (Qdrant/      â”‚  â”‚ (Neo4j)   â”‚ â”‚
â”‚  â”‚              â”‚  â”‚  Pinecone)    â”‚  â”‚ (çŸ¥è¯†å›¾è°±) â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  LLM Services                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ GPT-4 / Claudeâ”‚ â”‚ Embedding    â”‚                  â”‚
â”‚  â”‚ (æ¨ç†/ç”Ÿæˆ)    â”‚  â”‚ Model        â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## å…«ã€æ€§èƒ½ä¼˜åŒ–

### 8.1 ç¼“å­˜ç­–ç•¥
```python
# çƒ­é—¨çŸ¥è¯†ç¼“å­˜
cache = {
    "codifiable_rules": TTLCache(maxsize=1000, ttl=3600),
    "contextual_patterns": TTLCache(maxsize=500, ttl=1800),
    "meta_insights": TTLCache(maxsize=100, ttl=86400)
}
```

### 8.2 å¼‚æ­¥å¤„ç†
```python
# çŸ¥è¯†æå–å¼‚æ­¥åŒ–
async def extract_knowledge_async(interaction):
    task = asyncio.create_task(
        process_interaction(interaction)
    )
    # ä¸é˜»å¡ç”¨æˆ·ï¼Œåå°å¤„ç†
```

---

## ä¹ã€ç›‘æ§ä¸è¯„ä¼°

### 9.1 çŸ¥è¯†è´¨é‡æŒ‡æ ‡
```yaml
å¯ç¼–ç çŸ¥è¯†:
  - æ‰§è¡ŒæˆåŠŸç‡ > 85%
  - å¹³å‡æ•ˆæœåå·® < 15%

æƒ…å¢ƒçŸ¥è¯†:
  - éªŒè¯æˆåŠŸç‡ > 75%
  - ä½¿ç”¨é¢‘ç‡ > 5 æ¬¡/æœˆ

å…ƒå±‚çŸ¥è¯†:
  - ä»·å€¼åˆ›é€  > $10,000/æ´å¯Ÿ
  - å¤ç”¨æ¬¡æ•° > 10
```

### 9.2 ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡
```yaml
å“åº”æ—¶é—´:
  - è§„åˆ™æŸ¥è¯¢ < 100ms
  - æƒ…å¢ƒåŒ¹é… < 500ms
  - å…ƒå±‚æ¨ç† < 2s

å‡†ç¡®æ€§:
  - è§„åˆ™é€‚ç”¨æ€§ > 95%
  - æƒ…å¢ƒåŒ¹é…ç›¸å…³æ€§ > 80%
  - æ´å¯Ÿæ¨èæ¥å—ç‡ > 60%
```

---

## åã€æ€»ç»“

### æ ¸å¿ƒæŠ€æœ¯æ ˆ
- **å¯ç¼–ç çŸ¥è¯†**ï¼šè§„åˆ™å¼•æ“ + PostgreSQL
- **æƒ…å¢ƒçŸ¥è¯†**ï¼šRAG (Embedding + Vector DB + LLM)
- **å…ƒå±‚çŸ¥è¯†**ï¼šç»“æ„åŒ–å­˜å‚¨ + æç¤ºè¯å·¥ç¨‹ + å¼•å¯¼å¼æ•è·

### å…³é”®åˆ›æ–°
1. **ä¸‰å±‚çŸ¥è¯†æ¶æ„**ï¼šåŒºåˆ†å¯ç¼–ç /æƒ…å¢ƒ/å…ƒå±‚
2. **ä½æ‘©æ“¦æ•è·**ï¼šåœ¨å·¥ä½œæµä¸­è‡ªç„¶æ²‰æ·€
3. **ç¼©æ”¾æç¤ºå¼•æ“**ï¼šä¸»åŠ¨æé†’è¢«å¿½è§†çš„å°ºåº¦
4. **çŸ¥è¯†é£è½®**ï¼šè´¡çŒ®-ä½¿ç”¨-æ”¶ç›Š-æ¿€åŠ±

### ä¸‹ä¸€æ­¥
1. å®ç° MVPï¼ˆæœ€å°å¯è¡Œäº§å“ï¼‰
2. åœ¨æ ‡æ†å®¢æˆ·éªŒè¯
3. è¿­ä»£ä¼˜åŒ–

### ç›¸å…³æ–‡æ¡£
- [äº§å“ä½“éªŒ](../product/domain-expert-ux.md) - ç”¨æˆ·å¦‚ä½•ä½¿ç”¨è¿™äº›æŠ€æœ¯
- [ä¸šåŠ¡æˆ˜ç•¥](../business/knowledge-strategy.md) - ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡
- [å†³ç­–è®°å½•](../decisions/002-vertical-knowledge-management.md) - æŠ€æœ¯é€‰å‹çš„èƒŒæ™¯
